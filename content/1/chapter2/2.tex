LLVM has switched to CMake from GNU autoconf due to higher flexibility in terms of choosing underlying build systems. Ever since, LLVM has come up with many custom CMake functions, macros, and rules to optimize its own usage. This section will give you an overview of the most important and frequently used ones among them. We will learn how and when to use them.

\subsubsubsection{2.2.1\hspace{0.2cm}Using the CMake function to add new libraries}

Libraries are the building blocks of the LLVM framework. However, when writing CMakeLists.txt for a new library, you shouldn't use the normal add\_library directive that appears in normal CMakeLists.txt files, as follows:

\begin{lstlisting}[style=styleCMake]
# In an in-tree CMakeLists.txt file…
add_library(MyLLVMPass SHARED
  MyPass.cpp) # Do NOT do this to add a new LLVM library
\end{lstlisting}

There are several drawbacks of using the vanilla add\_library here, as follows:

\begin{itemize}
\item As shown in Chapter 1, Saving Resources When Building LLVM, LLVM prefers to use a global CMake argument (that is, BUILD\_SHARED\_LIBS) to control whether all its component libraries should be built statically or dynamically. It's pretty hard to do that using the built-in directives.

\item Similar to the previous point, LLVM prefers to use a global CMake arguments to control some compile flags, such as whether or not to enable Runtime Type Information (RTTI) and C++ exception handling in the code base.

\item By using custom CMake functions/macros, LLVM can create its own component system, which provides a higher level of abstraction for developers to designate build target dependencies in an easier way.

\end{itemize}

Therefore, you should always use the add\_llvm\_component\_library CMake function shown here:

\begin{lstlisting}[style=styleCMake]
# In a CMakeLists.txt
add_llvm_component_library(LLVMFancyOpt
  FancyOpt.cpp)
\end{lstlisting}

Here, LLVMFancyOpt is the final library name and FancyOpt.cpp is the source file.

In regular CMake scripts, you can use target\_link\_libraries to designate a given target's library dependencies, and then use add\_dependencies to assign dependencies among different build targets to create explicit build orderings. There is an easier way to do those tasks when you're using LLVM's custom CMake functions to create library targets.

By using the LINK\_COMPONENTS argument in add\_llvm\_component\_library (or add\_llvm\_library, which is the underlying implementation of the former one), you can designate the target's linked components:

\begin{lstlisting}[style=styleCMake]
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp
	LINK_COMPONENTS
	Analysis ScalarOpts)
\end{lstlisting}

Alternatively, you can do the same thing with the LLVM\_LINK\_COMPONENTS variable, which is defined before the function call:

\begin{lstlisting}[style=styleCMake]
set(LLVM_LINK_COMPONENTS
	Analysis ScalarOpts)
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp)
\end{lstlisting}

Component libraries are nothing but normal libraries with a special meaning when it comes to the LLVM building blocks you can use. They're also included in the gigantic libLLVM library if you choose to build it. The component names are slightly different from the real library names. If you need the mapping from component names to library names, you can use the following CMake function:

\begin{lstlisting}[style=styleCMake]
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp
	LINK_LIBS
	${BOOST_LIBRARY})
\end{lstlisting}

If you want to directly link against a normal library (the non-LLVM component one), you can use the LINK\_LIBS argument:

\begin{lstlisting}[style=styleCMake]
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp
	LINK_LIBS
	${BOOST_LIBRARY})
\end{lstlisting}

To assign general build target dependencies to a library target (equivalent to add\_dependencies), you can use the DEPENDS argument:

\begin{lstlisting}[style=styleCMake]
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp
	DEPENDS
	intrinsics_gen)
\end{lstlisting}

intrinsics\_gen is a common target representing the procedure of generating header files containing LLVM intrinsics definitions.

\hspace*{\fill} \\
\noindent
\textbf{Adding one build target per folder}

Many LLVM custom CMake functions have a pitfall that involves source file detection. Let's say you have a directory structure like this:

\begin{tcolorbox}[colback=white,colframe=black]
\tt
/FancyOpt \\
\hspace*{0.5cm}|\_\_\_ FancyOpt.cpp \\
\hspace*{0.5cm}|\_\_\_ AggressiveFancyOpt.cpp \\
\hspace*{0.5cm}|\_\_\_ CMakeLists.txt
\end{tcolorbox}

Here, you have two source files, FancyOpt.cpp and AggressiveFancyOpt.cpp. As their names suggest, FancyOpt.cpp is the basic version of this optimization, while AggressiveFancyOpt.cpp is an alternative, more aggressive version of the same functionality. Naturally, you will want to split them into separate libraries so that users can choose if they wish to include the more aggressive one in their normal workload. So, you might write a CMakeLists.txt file like this:

\begin{lstlisting}[style=styleCMake]
# In /FancyOpt/CMakeLists.txt
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp)
add_llvm_component_library(LLVMAggressiveFancyOpt
	AggressiveFancyOpt.cpp)
\end{lstlisting}

Unfortunately, this would generate error messages telling you something to the effect of Found unknown source AggressiveFancyOpt.cpp … when processing the first add\_llvm\_component\_library statement.

LLVM's build system enforces a stricter rule to make sure that all C/C++ source files in the same folder are added to the same library, executable, or plugin. To fix this, it is necessary to split either file into a separate folder, like so:

\begin{tcolorbox}[colback=white,colframe=black]
\tt
/FancyOpt \\
\hspace*{0.5cm}|\_\_\_ FancyOpt.cpp \\
\hspace*{0.5cm}|\_\_\_ CMakeLists.txt \\
\hspace*{0.5cm}|\_\_\_ /AggressiveFancyOpt \\
\hspace*{1cm}|\_\_\_ AggressiveFancyOpt.cpp \\
\hspace*{1cm}|\_\_\_ CMakeLists.txt
\end{tcolorbox}

In /FancyOpt/CMakeLists.txt, we have the following:

\begin{lstlisting}[style=styleCMake]
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp)
add_subdirectory(AggressiveFancyOpt)
\end{lstlisting}

Finally, in /FancyOpt/AggressiveFancyOpt/CMakeLists.txt, we have the following:

\begin{lstlisting}[style=styleCMake]
add_llvm_component_library(LLVMAggressiveFancyOpt
	AggressiveFancyOpt.cpp)
\end{lstlisting}

These are the essentials of adding build targets for (component) libraries using LLVM's custom CMake directives. In the next two sections, we will show you how to add executable and Pass plugin build targets using a different set of LLVM-specific CMake directives.

\subsubsubsection{2.2.2\hspace{0.2cm}Using the CMake function to add executables and tools}

Similar to add\_llvm\_component\_library, to add a new executable target, we can use add\_llvm\_executable or add\_llvm\_tool:

\begin{lstlisting}[style=styleCMake]
add_llvm_tool(myLittleTool
	MyLittleTool.cpp)
\end{lstlisting}

These two functions have the same syntax. However, only targets created by add\_llvm\_tool will be included in the installations. There is also a global CMake variable, LLVM\_BUILD\_TOOLS, that enables/disables those LLVM tool targets.

Both functions can also use the DEPENDS argument to assign dependencies, similar to add\_llvm\_library, which we introduced earlier. However, you can only use the LLVM\_LINK\_COMPONENTS variable to designate components to link.

\subsubsubsection{2.2.3\hspace{0.2cm}Using the CMake function to add Pass plugins}

While we will cover Pass plugin development later in this book, adding a build target for a Pass plugin couldn't be any easier than now (compared to earlier LLVM versions, which were still using add\_llvm\_library with some special arguments). We can simply use the following command:

\begin{lstlisting}[style=styleCMake]
add_llvm_pass_plugin(MyPass
	HelloWorldPass.cpp)
\end{lstlisting}

The LINK\_COMPONENTS, LINK\_LIBS, and DEPENDS arguments are also available here, with the same usages and functionalities as in add\_llvm\_component\_library.

These are some of the most common and important LLVM-specific CMake directives. Using these directives can not only make your CMake code more concise but also help synchronize it with LLVM's own build system, in case you want to do some in-tree development. In the next section, we will show you how to integrate LLVM into an out-oftree CMake project, and leverage the knowledge we learned in this chapter.

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black, title=In-tree versus out-of-tree development]
\hspace*{0.7cm}In this book, in-tree development means contributing code directly to the LLVM project, such as fixing LLVM bugs or adding new features to the existing LLVM libraries. Out-of-tree development, on the other hand, either represents creating extensions for LLVM (writing an LLVM pass, for example) or using LLVM libraries in some other projects (using LLVM's code generation libraries to implement your own programming language, for example).
\end{tcolorbox}














