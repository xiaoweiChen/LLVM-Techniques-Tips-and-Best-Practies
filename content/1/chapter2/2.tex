因为对构建系统灵活性的要求，LLVM的构建方式已经从GNU autoconf切换到CMake。从那以后，LLVM提出了许多定制的CMake函数、宏和规则来优化自己的使用。本节将为您概述其中最重要和最常用的几个。我们将学习如何以及何时使用它们。

\subsubsubsection{2.2.1\hspace{0.2cm}使用CMake添加新的库}

库是LLVM框架的基本构建块。要为一个新库编写CMakeLists.txt时，不要使用\texttt{add\_library}指令:

\begin{lstlisting}[style=styleCMake]
# In an in-tree CMakeLists.txt file…
add_library(MyLLVMPass SHARED
  MyPass.cpp) # Do NOT do this to add a new LLVM library
\end{lstlisting}

使用\texttt{add\_library}有几个缺点:

\begin{itemize}
\item 第1章在构建LLVM时，LLVM更喜欢使用全局CMake参数(即\texttt{BUILD\_SHARED\_LIBS})来控制所有的组件库是静态构建还是动态构建。使用内置指令很难做到这一点的。

\item 类似的，LLVM更喜欢使用一个全局的CMake参数来控制一些编译标志，比如是否启用\textbf{运行时类型信息(RTTI)}和代码库中的\textbf{\texttt{C++}异常处理}。

\item 通过使用定制的CMake函数/宏，LLVM可以创建自己的组件系统，这为开发人员提供了更高级别的抽象，可以以更容易的方式指定构建目标依赖项。

\end{itemize}

因此，可以使用\texttt{add\_llvm\_component\_library}：

\begin{lstlisting}[style=styleCMake]
# In a CMakeLists.txt
add_llvm_component_library(LLVMFancyOpt
  FancyOpt.cpp)
\end{lstlisting}

这里，\texttt{LLVMFancyOpt}是库名，\texttt{FancyOpt.cpp}是源文件。

常规的CMake脚本中，可以使用\texttt{target\_link\_libraries}来指定给定目标的库依赖关系，然后使用\texttt{add\_dependencies}在不同的构建目标之间，分配依赖关系来创建显式的描绘构建顺序。当使用LLVM的自定义CMake函数来创建库目标时，有一个更简单的方法来完成这些任务。

通过使用\texttt{add\_llvm\_component\_library}中的\texttt{LINK\_COMPONENTS}参数(或\texttt{add\_llvm\_library}，是前一个的更底层实现)，可以为目标指定需要链接的组件:

\begin{lstlisting}[style=styleCMake]
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp
	LINK_COMPONENTS
	Analysis ScalarOpts)
\end{lstlisting}

或者，可以对\texttt{LLVM\_LINK\_COMPONENTS}变量做同样的事情，而且需要在函数调用之前定义:

\begin{lstlisting}[style=styleCMake]
set(LLVM_LINK_COMPONENTS
	Analysis ScalarOpts)
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp)
\end{lstlisting}

当需要使用的LLVM构建块时，组件库不过是具有特殊意义的普通库。如果选择构建它，其就会包含在巨大的libLLVM库中，组件名与真正的库名会略有不同。如果需要从组件名映射到库名，可以使用下面的CMake函数:

\begin{lstlisting}[style=styleCMake]
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp
	LINK_LIBS
	${BOOST_LIBRARY})
\end{lstlisting}

如果想直接链接到一个普通的库(非LLVM组件)，可以使用\texttt{LINK\_LIBS}参数:

\begin{lstlisting}[style=styleCMake]
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp
	LINK_LIBS
	${BOOST_LIBRARY})
\end{lstlisting}

要将常规构建目标依赖分配给库目标(相当于\texttt{add\_dependencies})，可以使用\texttt{DEPENDS}参数:

\begin{lstlisting}[style=styleCMake]
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp
	DEPENDS
	intrinsics_gen)
\end{lstlisting}

\texttt{intrinsics\_gen}是一个常见的目标，表示生成包含LLVM intrinsics的头文件。

\hspace*{\fill} \\
\noindent
\textbf{为每个文件夹添加一个构建目标}

许多LLVM定制的CMake函数都有涉及到源文件检测陷阱。假设有一个这样的目录结构:

\begin{tcolorbox}[colback=white,colframe=black]
\tt
\zihao{-5}
/FancyOpt \\
\hspace*{0.5cm}|\_\_\_ FancyOpt.cpp \\
\hspace*{0.5cm}|\_\_\_ AggressiveFancyOpt.cpp \\
\hspace*{0.5cm}|\_\_\_ CMakeLists.txt
\end{tcolorbox}

Here, you have two source files, FancyOpt.cpp and AggressiveFancyOpt.cpp. As their names suggest, FancyOpt.cpp is the basic version of this optimization, while AggressiveFancyOpt.cpp is an alternative, more aggressive version of the same functionality. Naturally, you will want to split them into separate libraries so that users can choose if they wish to include the more aggressive one in their normal workload. So, you might write a CMakeLists.txt file like this:

\begin{lstlisting}[style=styleCMake]
# In /FancyOpt/CMakeLists.txt
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp)
add_llvm_component_library(LLVMAggressiveFancyOpt
	AggressiveFancyOpt.cpp)
\end{lstlisting}

Unfortunately, this would generate error messages telling you something to the effect of Found unknown source AggressiveFancyOpt.cpp … when processing the first add\_llvm\_component\_library statement.

LLVM's build system enforces a stricter rule to make sure that all C/C++ source files in the same folder are added to the same library, executable, or plugin. To fix this, it is necessary to split either file into a separate folder, like so:

\begin{tcolorbox}[colback=white,colframe=black]
\tt
/FancyOpt \\
\hspace*{0.5cm}|\_\_\_ FancyOpt.cpp \\
\hspace*{0.5cm}|\_\_\_ CMakeLists.txt \\
\hspace*{0.5cm}|\_\_\_ /AggressiveFancyOpt \\
\hspace*{1cm}|\_\_\_ AggressiveFancyOpt.cpp \\
\hspace*{1cm}|\_\_\_ CMakeLists.txt
\end{tcolorbox}

In /FancyOpt/CMakeLists.txt, we have the following:

\begin{lstlisting}[style=styleCMake]
add_llvm_component_library(LLVMFancyOpt
	FancyOpt.cpp)
add_subdirectory(AggressiveFancyOpt)
\end{lstlisting}

Finally, in /FancyOpt/AggressiveFancyOpt/CMakeLists.txt, we have the following:

\begin{lstlisting}[style=styleCMake]
add_llvm_component_library(LLVMAggressiveFancyOpt
	AggressiveFancyOpt.cpp)
\end{lstlisting}

These are the essentials of adding build targets for (component) libraries using LLVM's custom CMake directives. In the next two sections, we will show you how to add executable and Pass plugin build targets using a different set of LLVM-specific CMake directives.

\subsubsubsection{2.2.2\hspace{0.2cm}Using the CMake function to add executables and tools}

Similar to add\_llvm\_component\_library, to add a new executable target, we can use add\_llvm\_executable or add\_llvm\_tool:

\begin{lstlisting}[style=styleCMake]
add_llvm_tool(myLittleTool
	MyLittleTool.cpp)
\end{lstlisting}

These two functions have the same syntax. However, only targets created by add\_llvm\_tool will be included in the installations. There is also a global CMake variable, LLVM\_BUILD\_TOOLS, that enables/disables those LLVM tool targets.

Both functions can also use the DEPENDS argument to assign dependencies, similar to add\_llvm\_library, which we introduced earlier. However, you can only use the LLVM\_LINK\_COMPONENTS variable to designate components to link.

\subsubsubsection{2.2.3\hspace{0.2cm}Using the CMake function to add Pass plugins}

While we will cover Pass plugin development later in this book, adding a build target for a Pass plugin couldn't be any easier than now (compared to earlier LLVM versions, which were still using add\_llvm\_library with some special arguments). We can simply use the following command:

\begin{lstlisting}[style=styleCMake]
add_llvm_pass_plugin(MyPass
	HelloWorldPass.cpp)
\end{lstlisting}

The LINK\_COMPONENTS, LINK\_LIBS, and DEPENDS arguments are also available here, with the same usages and functionalities as in add\_llvm\_component\_library.

These are some of the most common and important LLVM-specific CMake directives. Using these directives can not only make your CMake code more concise but also help synchronize it with LLVM's own build system, in case you want to do some in-tree development. In the next section, we will show you how to integrate LLVM into an out-oftree CMake project, and leverage the knowledge we learned in this chapter.

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black, fonttitle=\bfseries,title=In-tree versus out-of-tree development]
\hspace*{0.7cm}In this book, in-tree development means contributing code directly to the LLVM project, such as fixing LLVM bugs or adding new features to the existing LLVM libraries. Out-of-tree development, on the other hand, either represents creating extensions for LLVM (writing an LLVM pass, for example) or using LLVM libraries in some other projects (using LLVM's code generation libraries to implement your own programming language, for example).
\end{tcolorbox}














