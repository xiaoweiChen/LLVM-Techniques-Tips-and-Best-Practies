有了前面部分的知识，是时候编写我们自己的甜甜圈了!我们将按照以下步骤进行:

\begin{enumerate}
\item 要创建的第一个文件是\texttt{Kitchen.td}。定义了烹饪环境，包括测量单位、设备和程序，仅举几个方面。我们将从测量单位开始:

\begin{lstlisting}[style=styleCXX]
class Unit {
	string Text;
	bit Imperial;
}
\end{lstlisting}

这里，Text字段是菜谱上显示的文本格式，Imperial只是一个布尔标志，用于标记这个单位是英制还是公制单位。每个重量或体积单元将是继承自这个类的一个记录——下面的代码是一个例子:

\begin{lstlisting}[style=styleCXX]
def gram_unit : Unit {
	let Imperial = false;
	let Text = "g";
}
def tbsp_unit : Unit {
	let Imperial = true;
	let Text = "tbsp";
}
\end{lstlisting}

我们需要创建许多度量单位，但是代码已经相当长了。简化和使它更可读的方法是使用类模板参数，如下所示:

\begin{lstlisting}[style=styleCXX]
class Unit<bit imperial, string text> {
	string Text = text;
	bit Imperial = imperial;
}
def gram_unit : Unit<false, "g">;
def tbsp_unit : Unit<true, "tbsp">;
\end{lstlisting}

与\texttt{C++}的模板参数不同，TableGen中的模板参数只接受具体的值，只是为字段赋值的另一种方法。

\item 由于TableGen不支持浮点数，需要定义一些方法来表示数字，例如\textbf{1和$\frac{1}{4}$杯}或\textbf{94.87g的面粉}。一种解决办法是使用定点数，如下所示:

\begin{lstlisting}[style=styleCXX]
class FixedPoint<int integral, int decimal = 0> {
	int Integral = integral;
	int DecimalPoint = decimal;
}
def one_plus_one_quarter : FixedPoint<125, 2>; // Shown
as 1.25
\end{lstlisting}

提到\texttt{Integral}和\texttt{DecimalPoint}字段，\texttt{FixedPoint}类表示的值等于下面的公式:

\textit{Integral * 10\^(-DecimalPoint)}

$\frac{1}{4}$、$\frac{1}{2}$和$\frac{3}{4}$显然是常用的测量单位(特别是英制单位，如美制杯)，使用一个helper类来创建它们可能是个好主意:

\begin{lstlisting}[style=styleCXX]
class NplusQuarter<int n, bits<2> num_quarter> :
FixedPoint<?, 2> {…}
def one_plus_one_quarter : NplusQuarter<1,1>; // Shown as
1.25
\end{lstlisting}

这将使表示数量，如N和$\frac{1}{4}$ 杯或N和$\frac{1}{2}$杯变得更加容易。

TableGen类也有继承——一个类可以继承一个或多个类。由于TableGen没有成员函数/方法的概念，继承类只是简单地集成字段。

\item 为了实现\texttt{NplusQuarter}，特别是从\texttt{NplusQuarter}类模板参数到\texttt{FixedPoint}的转换，我们需要一些简单的算术计算，这就是使用TableGen的叹号操作符的位置:

\begin{lstlisting}[style=styleCXX]
class NplusQuarter<int n, bits<2> num_quarter> :
FixedPoint<?, 2> {
	int Part1 = !mul(n, 100);
	int Part2 = !mul(25, !cast<int>(num_quarter{1...0}));
	let Integral = !add(Part1, Part2);
}
\end{lstlisting}

Another interesting syntax that appeared is the bit extraction (or slicing) on the num\_quarter variable. By writing num\_quarter{1…0}, this gives you a bits value that is equal to the 0th and first bit of num\_quarter. There are some other variants of this technique. For example, it can slice a non-continuous range of bits, as follows:

\begin{lstlisting}[style=styleCXX]
num_quarter{8…6,4,2…0}
\end{lstlisting}

Or, it can extract bits in reversed ordering, as follows:

\begin{lstlisting}[style=styleCXX]
num_quarter{1…7}
\end{lstlisting}

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black, fonttitle=\bfseries,title=Note]
\hspace*{0.7cm}You might wonder why the code needs to extract the smallest 2 bits explicitly even it has declared that num\_quarter has a width of 2 bits (the bits<2> type). It turned out that for some reason, TableGen will not stop anyone from assigning values greater than 3 into num\_quarter, like this: def x : NplusQuarter<1,999>.
\end{tcolorbox}

\item With the measuring units and number format, we can finally deal with the ingredients needed for this recipe. First, let's use a separated file, Ingredients.td, to store all the ingredient records. To use all the things mentioned earlier, we can import Kitchen.td by using the include syntax, as follows:

\begin{lstlisting}[style=styleCXX]
// In Ingredients.td…
include "Kitchen.td"
\end{lstlisting}

Then, a base class of all ingredients is created to carry some common fields, as follows:

\begin{lstlisting}[style=styleCXX]
class IngredientBase<Unit unit> {
	Unit TheUnit = unit;
	FixedPoint Quantity = FixedPoint<0>;
}
\end{lstlisting}

Each kind of ingredient is represented by a class derived from IngredientBase, with parameters to specify the quantity needed by a recipe, and the unit used to measure this ingredient. Take milk, for example, as shown in the following code snippet:

\begin{lstlisting}[style=styleCXX]
class Milk<int integral, int num_quarter> :
IngredientBase<cup_unit> {
	let Quantity = NplusQuarter<integral, num_quarter>;
}
\end{lstlisting}

The cup\_unit put at the template argument for IngredientBase tells us that milk is measured by a US cup unit, and its quantity is to be determined later by the Milk class template arguments.

When writing a recipe, each required ingredient is represented by a record created from one of these ingredient class types:

\begin{lstlisting}[style=styleCXX]
def ingredient_milk : Milk<1,2>; // Need 1.5 cup of milk
\end{lstlisting}

\item Some ingredients, however, always come together—for example, lemon peel and lemon juice, egg yolk, and egg white. That is, if you have two egg yolks, then there must be two servings of egg white. However, if we need to create a record and assign a quantity for each of the ingredients one by one, there will be a lot of duplicate code. A more elegant way to solve this problem is by using TableGen's multiclass syntax.

Taking the following egg example, assume we want to create WholeEgg, EggWhite, and EggYolk records at once with the same quantity, and define the multiclass first:

\begin{lstlisting}[style=styleCXX]
multiclass Egg<int num> {
	def _whole : WholeEgg {
		let Quantity = FixedPoint<num>;
	}
	def _yolk : EggYolk {
		let Quantity = FixedPoint<num>;
	}
	def _white : EggWhite {
		let Quantity = FixedPoint<num>;
	}
}
\end{lstlisting}

When writing the recipe, use the defm syntax to create multiclass records, as follows:

\begin{lstlisting}[style=styleCXX]
defm egg_ingredient : Egg<3>;
\end{lstlisting}

After using defm, three records will  actually be created: egg\_ingredient\_whole, egg\_ingredient\_yolk, and egg\_ingredient\_white, inheriting from WholeEgg, EggYolk, and EggWhite, respectively.

\item Finally, we need a way to describe the steps to make a donut. Many recipes have some preparation steps that don't need to be done in a specific order. Take the donut recipe here, for example: preheating the oil can be done at any time before the donuts are ready to be fried. Thus, it might be a good idea to express baking steps in a dag type.

Let's first create the class to represent a baking step, as follows:

\begin{lstlisting}[style=styleCXX]
class Step<dag action, Duration duration, string custom_
format> {
	dag Action = action;
	Duration TheDuration = duration;
	string CustomFormat = custom_format;
	string Note;
}
\end{lstlisting}

The Action field carries the baking instructions and information about the ingredients used. Here is an example:

\begin{lstlisting}[style=styleCXX]
def mix : Action<"mix",…>;
def milk : Milk<…>;
def flour : Flour<…>;
def step_mixing : Step<(mix milk, flour), …>;
\end{lstlisting}

Action is just a class used for describing movements. The following snippet represents the fact that step\_mixing2 is using the outcome from step\_mixing (maybe a raw dough) and mixing it with butter:

\begin{lstlisting}[style=styleCXX]
…
def step_mixing : Step<(mix milk, flour), …>;
def step_mixing2 : Step<(mix step_mixing, butter), …>;
\end{lstlisting}

Eventually, all of the Step records will form a DAG, in which a vertex will either be a step or an ingredient record.

We're also annotating our dag operator and operand with tags, as follows:

\begin{lstlisting}[style=styleCXX]
def step_mixing2 : Step<(mix:$action step_mixing:$dough, butter)>
\end{lstlisting}

In the previous section, Introduction to TableGen syntax, we said that these dag tags have no immediate effect in TableGen code, except affecting how TableGen backends handle the current record—for example, if we have a string type field, CustomFormat, in the Step class, as follows:

\begin{lstlisting}[style=styleCXX]
def step_prep : Step<(heat:$action fry_oil:$oil, oil_
temp:$temp)> {
	let CustomFormat = "$action the $oil until $temp";
}
\end{lstlisting}

With the field content shown, we can replace \$action, \$oil, and \$temp in the string with the textual representation of those records, generating a string such as heat the peanut oil until it reaches 300 F.

\end{enumerate}

And that wraps up this section of this chapter. In the next section, the goal is to develop a custom TableGen backend to take the TableGen version recipe here as input and print out a normal plaintext recipe.




















