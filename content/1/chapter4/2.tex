

This section serves as a quick tour of all the important and common TableGen syntax, providing all the essential knowledge to get hands-on, writing a donut recipe in TableGen in the next section.

TableGen is a domain-specific programming language used for modeling custom data layouts. Despite being a programming language, it does something quite different from conventional languages. Conventional programming languages usually describe actions performed on the (input) data, how they interact with the environment, and how they generate results, regardless of the programming paradigms (imperative, functional, eventdriven…) you adopt. TableGen, in contrast, barely describes any actions.

TableGen is designed only to describe structural static data. First, developers define the layout—which is essentially just a table with many fields—of their desired data structure. They then need to fill data into those layouts right away as most of the fields are populated/initialized. The latter part is probably what makes TableGen unique: many programming languages or frameworks provide ways to design your domain-specific data structures (for example, Google's Protocol Buffers), but in those scenarios, data is usually filled in dynamically, mostly in the code that consumes the DSL part.

Structured Query Language (SQL) shares many aspects with TableGen: both SQL and TableGen (only) handle structural data and have a way to define the layout. In SQL, it's TABLE; and in TableGen, it's class, which will be introduced later on in this section. However, SQL provides much more functions other than crafting the layout. It can also query (actually, that's where its name came from: Structured Query Language) and update data dynamically, which are absent in TableGen. However, later in this chapter, you will see that TableGen provides a nice framework to flexibly process and interpret this TableGen-defined data.

We'll now introduce four important TableGen constructions, as follows:

\begin{itemize}
\item Layout and records
\item Bang operators
\item Multiclass
\item The Directed-Acyclic Graph (DAG) data type
\end{itemize}

\subsubsubsection{4.2.1\hspace{0.2cm}Layout and records}

Given the fact that TableGen is just a more fancy and expressive way to describe structural data, it's pretty straightforward to think that there is a primitive representation for the data's layout, and representation for the instantiated data. The layout is realized by the class syntax, as shown in the following code snippet:

\begin{lstlisting}[style=styleCXX]
class Person {
	string Name = "John Smith";
	int Age;
}
\end{lstlisting}

As shown here, a class is similar to a struct in C and many other programming languages, which only contains a group of data fields. Each field has a type, which can be any of the primitive types (int, string, bit, and so on) or another user-defined class type. A field can also assign a default value such as John Smith.

After looking a layout, it's time to create an instance (or a record, in TableGen's terms), out of it, as follows:

\begin{lstlisting}[style=styleCXX]
def john_smith : Person;
\end{lstlisting}

Here, john\_smith is a record using Person as a template so that it also has two fields— Name and Age—with the Name field filled with the value John Smith. This looks pretty straightforward, but recall that TableGen should define static data and that most fields should be filled with values. Also, in this case, the Age field is still left uninitialized. You can populate its value by overriding with a bracket closure and statements within, as follows:

\begin{lstlisting}[style=styleCXX]
def john_smith : Person {
	let Age = 87;
}
\end{lstlisting}

You can even define new fields specifically for the john\_smith record, as follows:

\begin{lstlisting}[style=styleCXX]
def john_smith : Person {
	let Age = 87;
	string Job = "Teacher";
}
\end{lstlisting}

Just be aware that you can only override fields (using the let keyword) that have been declared, just as with many other programming languages.

\subsubsubsection{4.2.1\hspace{0.2cm}Bang operators}

Bang operators are a group of functions performing simple tasks such as basic arithmetic or casting on values in TableGen. Here is a simple example of converting kilograms to grams:

\begin{lstlisting}[style=styleCXX]
class Weight<int kilogram> {
	int Gram = !mul(kilogram, 1000);
}
\end{lstlisting}

Common operators include arithmetic and bitwise operators (to name but a few), and some of these are outlined here:

\begin{itemize}
\item !add(a, b): For arithmetic addition
\item !sub(a, b): For arithmetic subtraction
\item !mul(a, b): For arithmetic multiplication
\item !and(a, b): For logical AND operations
\item !or(a, b): For logical OR operations
\item !xor(a, b): For logical XOR operations
\end{itemize}

We also use conditional operators, and a few are outlined here:

\begin{itemize}
\item !ge(a, b): Returns 1 if a >= b, and 0 otherwise
\item !gt(a, b): Returns 1 if a > b, and 0 otherwise
\item !le(a, b): Returns 1 if a <= b, and 0 otherwise
\item !lt(a, b): Returns 1 if a < b, and 0 otherwise
\item !eq(a, b): Returns 1 if a == b, and 0 otherwise
\end{itemize}

Other interesting operators include the following:

\begin{itemize}
\item !cast<type>(x): This operator performs type casting on the x operand, according to the type parameter. In cases where the type is a numerical type, such as with int or bits, this performs normal arithmetic type casting. In some special cases, we have the following scenarios:

If type is string and x is a record, this returns the record's name.

If x is a string, it is treated as the name of a record. TableGen will look up all the record definitions so far and cast the one with the name of x and return it with a type that matches the type parameter.

\item !if(pred, then, else): This operator returns the then expression if pred is 1, and returns the else expression otherwise.
\item !cond(cond1 : val1, cond2 : val2, …, condN : valN): This operator is an enhanced version of the !if operator. It will continuously evaluate cond1…condN until one of the expressions returns 1, before returning its associated val expression.
\end{itemize}

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black, fonttitle=\bfseries,title=Note]
\hspace*{0.7cm}Unlike functions, which are evaluated during runtime, bang operators are more like macros, which are evaluated during build time—or in TableGen's terminology, when those syntaxes are processed by TableGen backends.
\end{tcolorbox}

\subsubsubsection{4.2.3\hspace{0.2cm}Multiclass}

There are many cases where we want to define multiple records at once. For example, the following snippet tries to create auto part records for multiple cars:

\begin{lstlisting}[style=styleCXX]
class AutoPart<int quantity> {…}

def car1_fuel_tank : AutoPart<1>;
def car1_engine : AutoPart<1>;
def car1_wheels : AutoPart<4>;
…
def car2_fuel_tank : AutoPart<1>;
def car2_engine : AutoPart<1>;
def car2_wheels : AutoPart<4>;
…
\end{lstlisting}

We can further simplify these by using the multiclass syntax, as follows:

\begin{lstlisting}[style=styleCXX]
class AutoPart<int quantity> {…}

multiclass Car<int quantity> {
	def _fuel_tank : AutoPart<quantity>;
	def _engine : AutoPart<quantity>;
	def _wheels : AutoPart<!mul(quantity, 4)>;
	…
}
\end{lstlisting}

When creating record instances, use the defm syntax instead of def, as follows:

\begin{lstlisting}[style=styleCXX]
defm car1 : Car<1>;
defm car2 : Car<1>;
\end{lstlisting}

Thus, at the end, it will still generate records with names such as car1\_fuel\_tank, car1\_engine, car2\_fuel\_tank, and so on.

Despite having class in its name, multiclass has nothing to do with a class. Instead of describing the layout of a record, multiclass acts as a template to generate records. Inside a multiclass template are the prospective records to be created and the records' name suffix after the template is expanded. For example, the defm car1 : Car<1> directive in the preceding snippet will eventually be expanded into three def directives, as follows:

\begin{itemize}
\item def car1\_fuel\_tank : AutoPart<1>;
\item def car1\_engine : AutoPart<1>;
\item def car1\_wheels : AutoPart<!mul(1, 4)>;
\end{itemize}

As you can see in the preceding list, the name suffixes we found inside multiclass (for instance, \_fuel\_tank) was concatenated with the name appearing after defm—car1 in this case. Also, the quantity template argument from multiclass, was also instantiated into every expanded record.

In short, multiclass tries to extract common parameters from multiple record instances and make it possible to create them at once.

\subsubsubsection{4.2.4\hspace{0.2cm}The DAG data type}

In addition to conventional data types, TableGen has a pretty unique first-class type: the dag type that is used for expressing DAG instances. To create a DAG instance, you can use the following syntax:

\begin{lstlisting}[style=styleCXX]
(operator operand1, operand2,…, operandN)
\end{lstlisting}

While the operator can only be a record instance, operands (operand1…operandN) can have arbitrary types. Here is an example of trying to model an arithmetic expression, x * 2 + y + 8 * z:

\begin{lstlisting}[style=styleCXX]
class Variable {…}
class Operator {…}
class Expression<dag expr> {…}

// define variables
def x : Variable;
def y : Variable;
def z : Variable;

// define operators
def mul : Operator;
def plus : Operator;

// define expression
def tmp1 : Expression<(mul x, 2)>;
def tmp2 : Expression<(mul 8, z)>;
def result : Expression<(plus tmp1, tmp2, y)>;
\end{lstlisting}

Optionally, you can associate operator and/or each operand with a tag, as follows:

\begin{lstlisting}[style=styleCXX]
…
def tmp1 : Expression<(mul:$op x, 2)>;
def tmp2 : Expression<(mul:$op 8, z)>;
def result : Expression<(plus tmp1:$term1, tmp2:$term2,
y:$term3)>;
\end{lstlisting}

A tag always starts with a dollar sign, \$, followed by a user-defined tag name. These tags provide a logical description of each dag component and can be useful when processing DAGs in the TableGen backend.

In this section, we have gone through the principal components of the TableGen language and introduced some essential syntax. In the next section, we are going to get hands-on, writing a delicious donut recipe using TableGen.

















