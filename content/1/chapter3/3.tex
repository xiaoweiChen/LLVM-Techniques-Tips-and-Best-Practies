
\textbf{FileCheck}是LLVM的高级模式检查器，与Unix/Linux系统中的grep类似，使用基于行的上下文，从而提供了更强大而简单的语法。此外，可以将\texttt{FileCheck}指令放在测试目标旁，可以让测试用例自包含，使测试更容易理解。

虽然基本的\texttt{FileCheck}语法很容易上手，但\texttt{FileCheck}还有许多其他功能，它们才能真正展示\texttt{FileCheck}的强大功能，并极大地改善了开发者的测试体验——例如创建更简洁的测试脚本和解析更复杂的程序输出，本节将向您展示其中的一些技巧。

\subsubsubsection{3.3.1\hspace{0.2cm}准备示例项目}

首先需要构建\texttt{FileCheck}命令行工具。与前一节类似，在LLVM树中构建一个\texttt{check-XXX}(伪)目标是最简单的方法:

\begin{tcblisting}{commandshell={}}
$ ninja check-llvm-support
\end{tcblisting}

在本节中，我们将使用一个假想的命令行工具\texttt{js-obfuscator}，这是一个JavaScript 混淆工具。\textbf{混淆}是一种常用的技术，用于隐藏知识产权或加强安全保护。例如，可以在以下JavaScript代码中使用JavaScript混淆器:

\begin{lstlisting}[style=styleJavaScript]
const onLoginPOST = (req, resp) => {
	if(req.name == 'admin')
		resp.send('OK');
	else
		resp.sendError(403);
}
myReset.post('/console', onLoginPOST);
\end{lstlisting}

将转换成以下代码:

\begin{lstlisting}[style=styleJavaScript]
const t = "nikfmnsdzaO";
const aaa = (a, b) => {
	if(a.z[0] == t[9] && a.z[1] == t[7] &&…)
		b.f0(t[10] + t[2].toUpperCase());
	else
		b.f1(0x193);
}
G.f4(YYY, aaa);
\end{lstlisting}

这个工具将尽量使原始脚本让人看不懂。测试部分面临的挑战是，在验证其正确性的同时仍然为随机性保留足够的空间。简单地说，\texttt{js-obfuscator}只有4条混淆规则:

\begin{enumerate}
\item 只混淆局部变量名，包括形参。形式参数名以\textit{<小写单词><参数索引号>}格式进行混淆。局部变量名混淆成小写字母和大写字母的组合。

\item 如果用箭头语法来声明函数——例如，\texttt{foo = (arg1, arg2) => \{…\}}——箭头和左花括号\texttt{(=> \{})需要放在下一行。
	
\item 用不同表示形式的相同值替换文字数，例如：将87替换为0x57或87.000。

\item 当使用\texttt{-\,-shuffle-funcs}选项时，会改变顶层函数的声明/出现顺序。

\end{enumerate}

最后，下面的JavaScript代码是使用\texttt{js-obfuscator}的一个示例:

\begin{lstlisting}[style=styleJavaScript]
const square = x => x * x;
const cube = x => x * x * x;
const my_func1 = (input1, input2, input3) => {
	// TODO: Check if the arrow and curly brace are in the second
	// line
	// TODO: Check if local variable and parameter names are
	// obfuscated
	let intermediate = square(input3);
	let output = input1 + intermediate - input2;
	return output;
}
const my_func2 = (factor1, factor2) => {
	// TODO: Check if local variable and parameter names are
	// obfuscated
	let term2 = cube(factor1);
	// TODO: Check if literal numbers are obfuscated
	return my_func1(94, term2, factor2);
}
console.log(my_func2(1,2));
\end{lstlisting}

\subsubsubsection{3.3.2\hspace{0.2cm}书写FileCheck指令}

下面的步骤将填充前面代码中出现的\texttt{TODO}注释:

\begin{enumerate}
\item 根据行号，第一个任务是检查局部变量和参数是否正确地混淆。根据规范，形参有特殊的重命名规则(即\textit{<小写单词><参数索引号>})，所以使用普通的\texttt{CHECK}指令和FileCheck自己的正则表达式是这里最合适的解决方案:

\begin{lstlisting}[style=styleJavaScript]
// CHECK: my_func1 = ({{[a-z]+0}}, {{[a-z]+1}},
// {{[a-z]+2}})
const my_func1 = (input1, input2, input3) => {
…
\end{lstlisting}

FileCheck使用正则表达式的子集来进行模式匹配，使用\texttt{\{\{…\}\}}或\texttt{[[…]]}。

\item 这段代码看起来非常简单。当进行了混淆，代码也需要正确的语义。因此，除了检查格式之外，对参数的后续引用也需要重构，这就是要使用FileCheck的模式绑定的原因：

\begin{lstlisting}[style=styleJavaScript]
// CHECK: my_func1 = ([[A0:[a-z]+0]],
// [[A1:[a-z]+1]], [[A2:[a-z]+2]])
const my_func1 = (input1, input2, input3) => {
	// CHECK: square([[A2]])
	let intermediate = square(input3);
…
\end{lstlisting}

该代码使用\texttt{[[…]]}语法将形参的模式绑定为名称为\texttt{A0~A2}，其中绑定变量名和模式用冒号分开：\texttt{[[<绑定变量>:<模式>]]}。使用相同的\texttt{[[…]]}语法绑定变量的引用位置，不过没有了模式部分。

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black, fonttitle=\bfseries,title=Note]
\hspace*{0.7cm}一个绑定变量可以有多个定义点，其参考点将读取最后的定义值。
\end{tcolorbox}

\item Let's not forget the second rule – the arrow and left curly brace of the function header need to be put in the second line. To implement the concept of "the line after," we can use the CHECK-NEXT directive:

\begin{lstlisting}[style=styleJavaScript]
// CHECK: my_func1 = ([[A0:[a-z]+0]],
// [[A1:[a-z]+1]], [[A2:[a-z]+2]])
const my_func1 = (input1, input2, input3) => {
	// CHECK-NEXT: => {
\end{lstlisting}

Compared to the original CHECK directive, CHECK-NEXT will not only check if the pattern exists but also ensure that the pattern is in the line that follows the line matched by the previous directive.

\item Next, all the local variables and formal parameters are checked in my\_func1:

\begin{lstlisting}[style=styleJavaScript]
// CHECK: my_func1 = ([[A0:[a-z]+0]],
// [[A1:[a-z]+1]], [[A2:[a-z]+2]])
const my_func1 = (input1, input2, input3) => {
	// CHECK: let [[IM:[a-zA-Z]+]] = square([[A2]]);
	let intermediate = square(input3);
	// CHECK: let [[OUT:[a-zA-Z]+]] =
	// CHECK-SAME: [[A0]] + [[IM]] - [[A1]];
	let output = input1 + intermediate - input2;
	// CHECK: return [[OUT]];
	return output;
}
\end{lstlisting}

As highlighted in the preceding code, the CHECK-SAME directive was used to match the succeeding pattern in the exact same line. The rationale behind this is that FileCheck expected different CHECK directives to be matched in different lines. So, let's say part of the snippet was written like this:

\begin{lstlisting}[style=styleJavaScript]
// CHECK: let [[OUT:[a-zA-Z]+]] =
// CHECK: [[A0]] + [[IM]] - [[A1]];
\end{lstlisting}

It will only match code that spread across two lines or more, as shown here:

\begin{lstlisting}[style=styleJavaScript]
let BGHr =
	r0 + jkF + r1;
\end{lstlisting}

It will throw an error otherwise. This directive is especially useful if you wish to avoid writing a super long line of checking statements, thus making the testing scripts more concise and readable.

\item Going into my\_func2, now, it's time to check if the literal numbers have been obfuscated properly. The checking statement here is designed to accept any instances/patterns except the original numbers. Therefore, the CHECK-NOT directive will be sufficient here:

\begin{lstlisting}[style=styleJavaScript]
…
// CHECK: return my_func1(
// CHECK-NOT: 94
return my_func1(94,
				term2, factor2);
\end{lstlisting}

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black, fonttitle=\bfseries,title=Note]
\hspace*{0.7cm}The first CHECK directive is required. This is because CHECK-NOT will not move the cursor from the line before return my\_func1(94. Here, CHECK-NOT will give a false negative without a CHECK directive to move the cursor to the correct line first.
\end{tcolorbox}

In addition, CHECK-NOT is pretty useful to express the concept of not <a specific pattern>…but <the correct pattern> when it's used with CHECK-SAME, as we mentioned earlier.

For example, if the obfuscation rule states that all the literal numbers need to be obfuscated into their hexadecimal counterparts, then you can express the assertion of don't want to see 94… but want to see 0x5E/0x5e at the same place instead using the following code:

\begin{lstlisting}[style=styleJavaScript]
…
// CHECK: return my_func1
// CHECK-NOT: 94,
// CHECK-SAME: {{0x5[eE]}}
return my_func1(94,
				term2, factor2);
\end{lstlisting}

\item Now, only one obfuscation rule needs to be verified: when the js-obfuscator tool is supplied with an additional command-line option, -\,-shuffle-funcs, which effectively shuffles all top-level functions, we need to check whether the top-level functions maintain certain ordering, even after they have been shuffled. In JavaScript, functions are resolved when they're called. This means that cube, square, my\_func1, and my\_func2 can have an arbitrary ordering, as long as they're placed before the console.log(…) statement. To express this kind of flexibility, the CHECK-DAG directive can be pretty useful.

Adjacent CHECK-DAG directives will match texts in arbitrary orders. For example, let's say we have the following directives:

\begin{lstlisting}[style=styleJavaScript]
// CHECK-DAG: 123
// CHECK-DAG: 456
\end{lstlisting}

These directives will match the following content:

\begin{lstlisting}[style=styleJavaScript]
123
456
\end{lstlisting}

They will also match the following content:

\begin{lstlisting}[style=styleJavaScript]
456
123
\end{lstlisting}

However, this freedom of ordering will not hold across either a CHECK or CHECKNOT directive. For example, let's say we have these directives:

\begin{lstlisting}[style=styleJavaScript]
// CHECK-DAG: 123
// CHECK-DAG: 456
// CHECK: 789
// CHECK-DAG: abc
// CHECK-DAG: def
\end{lstlisting}

These directives will match the following text:

\begin{lstlisting}[style=styleJavaScript]
456
123
789
def
abc
\end{lstlisting}

However, they will not match the following text:

\begin{lstlisting}[style=styleJavaScript]
456
789
123
def
abc
\end{lstlisting}

\item Back to our motivated example, the obfuscation rule can be checked by using the following code:

\begin{lstlisting}[style=styleJavaScript]
…
// CHECK-DAG: const square =
// CHECK-DAG: const cube =
// CHECK-DAG: const my_func1 =
// CHECK-DAG: const my_func2 =
// CHECK: console.log
console.log(my_func2(1,2));
\end{lstlisting}

However, function shuffling will only happen if an additional command-line option is supplied to the tool. Fortunately, FileCheck provides a way to multiplex different check suites into a single file, where each suite can define how it runs and separates the checks from other suites.

\item The idea of the check prefix in FileCheck is pretty simple: you can create a check suite that runs independently with other suites. Instead of using the CHECK string, each suite will replace it with another string in all the directives mentioned earlier (CHECK-NOT and CHECK-SAME, to name a few), including CHECK itself, in order to distinguish it from other suites in the same file. For example, you can create a suite with the YOLO prefix so that that part of the example now looks as follows:

\begin{lstlisting}[style=styleJavaScript]
// YOLO: my_func2 = ([[A0:[a-z]+0]], [[A1:[a-z]+1]])
const my_func2 = (factor1, factor2) => {
…
// YOLO-NOT: return my_func1(94,
// YOLO-SAME: return my_func1({{0x5[eE]}},
return my_func1(94,
				term2, factor2);
…
\end{lstlisting}

To use a custom prefix, it needs to be specified in the -\,-check-prefix command-line option. Here, the FileCheck command invocation will look like this:

\begin{tcblisting}{commandshell={}}
$ cat test.out.js | FileCheck --check-prefix=YOLO test.js
\end{tcblisting}

\item Finally, let's go back to our example. The last obfuscation rule can be solved by using an alternative prefix for those CHECK-DAG directives:

\begin{lstlisting}[style=styleJavaScript]
…
// CHECK-SHUFFLE-DAG: const square =
// CHECK-SHUFFLE-DAG: const cube =
// CHECK-SHUFFLE-DAG: const my_func1 =
// CHECK-SHUFFLE-DAG: const my_func2 =
// CHECK-SHUFFLE: console.log
console.log(my_func2(1,2));
\end{lstlisting}

\end{enumerate}
This must be combined with the default check suite.  All the checks mentioned in this section can be run in two separate commands, as follows:

\begin{tcblisting}{commandshell={}}
# Running the default check suite
$ js-obfuscator test.js | FileCheck test.js
# Running check suite for the function shuffling option
$ js-obfuscator --shuffle-funcs test.js | \
    FileCheck --check-prefix=CHECK-SHUFFLE test.js
\end{tcblisting}

In this section, we have shown some advanced and useful FileCheck skills through our example project. These skills provide you with different ways to write validation patterns and make your LIT test script more concise.

So far, we have been talking about the testing methodology, which runs tests in a shelllike environment (that is, in the ShTest LIT format). In the next section, we are going to introduce an alternative LIT framework – the TestSuite framework and testing format that was originated from the llvm-test-suite project – which provides a different kind of useful testing methodology for LIT.







