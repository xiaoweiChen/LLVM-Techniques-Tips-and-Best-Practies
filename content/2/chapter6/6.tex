
这里有一些简单的问题和练习，读者们可以自己尝试一下:

\begin{enumerate}
\item 虽然大多数时候\texttt{Token}是从提供的源代码中获取的，但在某些情况下，\texttt{Token}可能会在预处理器中动态生成。例如，\texttt{\_\_LINE\_\_}内置宏会扩展为当前行号，而\texttt{\_\_DATE\_\_}宏会扩展为当前日期。Clang如何将生成的文本内容放入\texttt{SourceManager}的源代码缓冲区？Clang如何分配\texttt{SourceLocation}给这些令牌？

\item 当我们讨论实现一个自定义\texttt{PragmaHandler}时，可以利用\texttt{Preprocessor::Lex}来获取pragma名称后面的\texttt{Token}，直到我们遇到\texttt{eod}令牌类型。我们能继续在\texttt{eod}令牌之外进行词法分析吗?如果可以在\texttt{\#pragma}指令后使用任意令牌，你会做哪些有趣的事情?

\item 在\texttt{macro}保护项目的开发自定义预处理器插件和回调部分，警告消息的格式为\texttt{[warning] In <source location>:…}。显然，这不是我们通常从\texttt{clang}中看到的编译器警告。通常的警告会是这样，\texttt{<source location>: warning:…}，如下所示:

\begin{tcblisting}{commandshell={}}
./simple_warn.c:2:7: warning: unused variable 'y'…
  int y = x + 1;
       ^

1 warning generated.
\end{tcblisting}

在某些终端中，警告字符串是彩色的。我们如何打印这样的警告消息？在Clang有这样的基础设施吗?

\end{enumerate}












