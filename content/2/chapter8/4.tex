
上一节中，我们了解了如何在Clang中为驱动添加自定义标志，并了解了驱动如何将它们转换为前端接受的标志。本节中，我们将讨论工具链——驱动内部的一个重要模块，它能帮助驱动程序适应不同的平台。

记得在本章的第一部分，在图8.1中展示了驱动和工具链之间的关系:驱动程序可以根据目标平台选择合适的工具链，然后利用其基本信息做以下事情:

\begin{enumerate}
\item LExecute生成目标代码所需的正确的汇编器、链接器或任何工具。

\item 向编译器、汇编器或链接器传递特定于平台的标志。
\end{enumerate}

这些信息对于构建源代码至关重要，因为每个平台可能都有自己独特的特征，比如：系统库路径和受支持的汇编/链接器变体。没有它们，甚至无法生成正确的可执行文件或库。

本节希望帮助大家了解如何在将来为定制平台创建Clang工具链。Clang中的工具链框架足够强大，可以适应各种各样的用例，例如：可以创建一个类似于Linux上传统编译器的工具链——包括使用GNU AS进行组装和使用GNU LD进行链接——而不需要对默认库路径或编译器标志进行多次定制。另一方面，可以使用一个怪异的工具链，它甚至不使用Clang来编译源代码，而是使用一个专有的汇编器和带有不常见命令行标志的链接器。本节将尝试使用一个示例来演示最常见的用例，同时又能展示该框架的灵活性。

这一部分的组织如下:将从我们将要从事的项目的概述开始。在此之后，我们将把项目工作负载分解为三个部分——添加定制编译器选项、设置定制汇编器和设置定制链接器——然后将它们放在一起，结束本节。

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black, fonttitle=\bfseries,title=系统需求]	
\hspace*{0.7cm}作为另一个友好的提示，下面的项目只能在Linux系统上工作。请确保已安装OpenSSL。
\end{tcolorbox}

\subsubsubsection{8.4.1\hspace{0.2cm}项目概述}

我们将创建一个名为\textbf{Zipline}的工具链，它使用Clang(前端和后端)来进行普通的编译，但在汇编阶段使用\textbf{Base64}编码生成的汇编代码，并在链接阶段将这些Base64编码的文件打包成\textbf{ZIP文件}(或\texttt{.tarbell}文件)。

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black, fonttitle=\bfseries,title=Base64]	
\hspace*{0.7cm}Base64是一种编码方案，通常用于将二进制文件转换为纯文本。它可以很容易地在不支持二进制格式的上下文中传输(例如，HTTP报头)。还可以将Base64应用于普通文本文件，就像我们的例子一样。
\end{tcolorbox}

这个工具链在生产环境中基本上是无用的。它只是一个演示，模拟开发人员在为定制平台创建新工具链时可能遇到的常见情况。

这个工具链是通过自定义驱动标志\texttt{-ziplin}/\texttt{-\,-zipline}来启用。当提供该标志时，编译器会隐式地将\texttt{my\_include}文件夹添加到你的主目录中，作为搜索头文件路径，例如：上一节中，添加自定义驱动标志，我们的自定义\texttt{-fuse-simple-log}标志将隐式地在输入源代码中包含一个头文件\texttt{simple\_log.h}:

\begin{tcblisting}{commandshell={}}
$ ls
main.cc simple_log.h
$ clang++ -fuse-simple-log -fsyntax-only main.cc
$ # OK
\end{tcblisting}

然而，如果\texttt{simple\_log.h}不在当前目录中，就像前面的代码片段中那样，我们需要通过另一个标志指定它的路径:

\begin{tcblisting}{commandshell={}}
$ ls .
# No simple_log.h in current folder
main.cc
$ clang++ -fuse-simple-log=/path/to/simple_log.h -fsyntax-only
main.cc
$ # OK
\end{tcblisting}

在Zipline的帮助下，可以把\texttt{simple\_log.h}放在\texttt{/home/<user name>/my\_include}中，这样编译器就能找到它了:

\begin{tcblisting}{commandshell={}}
$ ls .
# No simple_log.h in current folder
main.cc
$ ls ~/my_include
simple_log.h
$ clang++ -zipline -fuse-simple-log -fsyntax-only main.cc
$ # OK
\end{tcblisting}

Zipline的第二个特性是，\texttt{clang}可执行文件将源代码编译成由Base64在\texttt{-c}标志下编码的汇编代码，该汇编代码将汇编文件(来自编译器)编译成一个目标文件。下面是命令示例:

\begin{tcblisting}{commandshell={}}
$ clang -zipline -c test.c
$ file test.o
test.o: ASCII text # Not (binary) object file anymore
$ cat test.o
CS50ZXh0CgkuZmlsZQkidGVzdC5jYyIKCS
5nbG9ibAlfWjNmb29pCgkucDJhbGln

bgk0LCAweDkwCgkudHlwZQlfWjNmb29p
LEBmdW5jdGlvbgpfWjNmb29pOgoJLmNm

… # Base64 encoded contents
$
\end{tcblisting}

前面的\texttt{file}命令显示生成的文件\texttt{test.o}，从之前使用\texttt{clang}开始，就不再是二进制格式的对象文件。这个文件的内容就是编译器后端生成的汇编代码(Base64编码)版本。

最后，Zipline用一个定制阶段替换了原来的链接阶段，这个定制阶段将前面提到的Base64编码的程序集文件打包并压缩到一个\texttt{.zip}文件中。下面是一个例子:

\begin{tcblisting}{commandshell={}}
$ clang -zipline test.c -o test.zip
$ file test.zip
test.zip: Zip archive, at least v2.0 to extract
$
\end{tcblisting}

如果解压\texttt{test.zip}，将发现这些解压的文件是Case64编码的程序集文件。

或者，我们可以使用Linux的\texttt{tar}和\texttt{gzip}工具将它们打包并压缩到Zipline中:

\begin{tcblisting}{commandshell={}}
$ clang -zipline -fuse-ld=tar test.c -o test.tar.gz
$ file test.tar.gz
test.tar.gz: gzip compressed data, from Unix, original size…
$
\end{tcblisting}

通过使用现有的\texttt{-fuse-ld=<链接器名称>}标志，我们可以在自定义链接阶段选择使用\texttt{zip}、\texttt{tar}或\texttt{gzip}。

下一节中，我们将为这个工具链创建框架代码，并展示如何向头文件搜索路径添加额外的文件夹路径。

\subsubsubsection{8.4.2\hspace{0.2cm}创建工具链并添加自定义的包含路径}

本节中，我们将为Zipline工具链创建框架，并展示如何在Zipline的编译阶段添加一个额外的包含文件夹路径——更确切地说，一个额外的\textbf{系统包含路径}。具体步骤如下:

\begin{enumerate}
\item 在添加工具链实现之前，不要忘记使用自定义驱动标志\texttt{-zipline}/\texttt{-\,-zipline}来启用工具链。使用我们在前一节学到的技能，添加自定义驱动标志来完成。在\texttt{clang/include/clang/Dri\\ver/Options.td}里面，我们将增加以下行:

\begin{lstlisting}[style=styleJavaScript]
// zipline toolchain
def zipline : Flag<["-", "--"], "zipline">,
Flags<[NoXarchOption]>;
\end{lstlisting}

同样，\texttt{Flag}说明这是一个布尔标志，而\texttt{NoXarchOption}说明这个标志是驱动唯一的。我们将很快使用这个驱动标志。

\item Clang中的工具链由\texttt{clang::driver::ToolChain}类表示。Clang支持的每个工具链都是从它派生出来的，源文件在\texttt{clang/lib/Driver/ToolChains}文件夹下。我们将在那里创建两个新文件:\texttt{Zipline.h}和\texttt{Zipline.cpp}。

\item 对于\texttt{Zipline.h}，先添加以下框架代码:

\begin{lstlisting}[style=styleCXX]
namespace clang {
namespace driver {
namespace toolchains {
struct LLVM_LIBRARY_VISIBILITY ZiplineToolChain
: public Generic_ELF {
	ZiplineToolChain(const Driver &D, const llvm::Triple
	&Triple, const llvm::opt::ArgList &Args)
	: Generic_ELF(D, Triple, Args) {}
	~ZiplineToolChain() override {}
	// Disable the integrated assembler
	bool IsIntegratedAssemblerDefault() const override
	{ return false; }
	bool useIntegratedAs() const override { return false; }
	void
	AddClangSystemIncludeArgs(const llvm::opt::ArgList
	&DriverArgs, llvm::opt::ArgStringList &CC1Args)
	const override;
protected:
	Tool *buildAssembler() const override;
	Tool *buildLinker() const override;
};
} // end namespace toolchains
} // end namespace driver
} // end namespace clang
\end{lstlisting}

我们在这里创建的\texttt{ZiplineToolChain}类，是从\texttt{Generic\_ELF}派生而来，\texttt{Generic\_ELF}是\texttt{ToolChain}的子类，专门用于使用ELF作为其执行格式的系统——包括Linux。除了父类之外，还有三个重要的方法，我们将在本节或后面的章节中实现:\texttt{AddClangSystemIncludeArgs}、\texttt{buildAssembler}和\texttt{buildLinker}。

\item \texttt{buildAssembler}和\texttt{buildLinker方}法生成的\texttt{Tool}实例分别表示要在汇编和链接阶段运行的命令或程序(我们将在下面几节中介绍它们)。现在，我们将实现\texttt{AddClangSystemIncludeArgs}方法。在\texttt{Zipline.cpp}中，我们将添加相应实现:

\begin{lstlisting}[style=styleCXX]
void ZiplineToolChain::AddClangSystemIncludeArgs(
                       const ArgList &DriverArgs,
                       ArgStringList &CC1Args) const {
	using namespace llvm;
	SmallString<16> CustomIncludePath;
	sys::fs::expand_tilde("~/my_include",
	                      CustomIncludePath);
	addSystemInclude(DriverArgs,
	                 CC1Args, CustomIncludePath.c_str());
}
\end{lstlisting}

我们在这里做的唯一一件事是使用\texttt{addSystemInclude}函数与位于主目录中的\texttt{my\_include}文件夹的路径。由于每个用户的主目录不同，我们使用\texttt{sys::fs::expand\_tilde}助手函数将\texttt{~/my\_include}(其中\texttt{~}表示Linux和Unix系统中的主目录)扩展到绝对路径中。另一方面，\texttt{addSystemInclude}函数可以将“\texttt{-internalisystem}”“\texttt{/path/to/my\_include}”标志添加到前端标志的列表中。\texttt{-internal-issystem}标志用于指定系统头文件的文件夹，包括标准库头文件和平台特定的头文件。

\item 最后，当Zipline工具链看到新创建的\texttt{-zipline}/\texttt{-\,-zipline}驱动标志时，需要我们教会驱动使用Zipline工具链。我们需要修改\texttt{clang/lib/Driver/Driver.cpp}中的 \texttt{Driver::getTool\\Chain}方法。\texttt{Driver::getToolChain}方法包含一个巨大的开关盒，用于根据目标操作系统和硬件架构选择不同的工具链(具体的情况，请浏览处理Linux系统的代码)。我们将在这里添加一个额外的分支条件:

\begin{lstlisting}[style=styleCXX]
const ToolChain
&Driver::getToolChain(const ArgList &Args,
const llvm::Triple &Target) const {
	…
	switch (Target.getOS()) {
		case llvm::Triple::Linux:
		…
		  else if (Args.hasArg(options::OPT_zipline))
		    TC = std::make_unique<toolchains::ZiplineToolChain>
		    (*this, Target, Args);
		…
		  break;
		case …
		case …
	}
}
\end{lstlisting}

额外的\texttt{else-if}语句基本上是说，如果目标操作系统是Linux，那么当指定\texttt{-zipline}/\texttt{-\,-zip\\line}时，我们将使用Zipline。

\end{enumerate}

这样，您就添加了Zipline的框架，并成功地告诉驱动程序在给定自定义驱动程序标志时使用Zipline。除此之外，还了解了如何向头文件搜索路径添加额外的系统库文件夹。

下一节中，我们将创建一个自定义汇编阶段，并将其连接到我们创建的工具链中。

\subsubsubsection{8.4.3\hspace{0.2cm}创建自定义汇编阶段}

As we mentioned in the Project overview section, instead of doing regular assembling to convert assembly code into an object file in the assembling stage of Zipline, we are invoking a program to convert the assembly file we generated from Clang into its Base64-encoded counterpart. Before we go deeper into its implementation, let's learn how each of these stages in a toolchain is represented.

In the previous section, we learned that a toolchain in Clang is represented by the ToolChain class. Each of these ToolChain instances is responsible for telling the driver what tool to run in each compilation stage – namely compiling, assembling, and linking. And this information is encapsulated inside a clang::driver::Tool type object. Recall the buildAssembler and buildLinker methods in the previous section; they return the very Tool type objects that depict the actions to perform and the tool to run in the assembling and linking stages, respectively. In this section, we will show you how to implement the Tool object that's returned by buildAssembler. Let's get started:

\begin{enumerate}
\item Let's go back to Zipline.h first. Here, we are adding an extra class, Assembler, inside the clang::driver::tools::zipline namespace:

\begin{lstlisting}[style=styleCXX]
namespace clang {
namespace driver {
namespace tools {
namespace zipline {
	struct LLVM_LIBRARY_VISIBILITY Assembler : public Tool {
		Assembler(const ToolChain &TC)
		  : Tool("zipeline::toBase64", "toBase64", TC) {}
		bool hasIntegratedCPP() const override { return false;
		}
	void ConstructJob(Compilation &C, const JobAction &JA,
	const InputInfo &Output,
	const InputInfoList &Inputs,
	const llvm::opt::ArgList &TCArgs,
	const char *LinkingOutput) const
	override;
};
} // end namespace zipline
} // end namespace tools

namespace toolchains {
struct LLVM_LIBRARY_VISIBILITY ZiplineToolChain … {
…
};
} // end namespace toolchains
} // end namespace driver
} // end namespace clang
\end{lstlisting}

Be careful because the newly created Assembler resides in the clang::driver::tools::zipline namespace, while ZiplineToolChain, which we created in the previous section, is in clang::driver::toolchains.

The Assembler::ConstructJob method is where we will put our logic for invoking Base64 encoding tools.

\item Inside Zipline.cpp, we will implement the method body of Assembler::ConstructJob:

\begin{lstlisting}[style=styleCXX]
void
tools::zipline::Assembler::ConstructJob(Compilation &C,
							const JobAction &JA,
							const InputInfo &Output,
							const InputInfoList &Inputs,
							const ArgList &Args,
							const char *LinkingOutput)
							const {
	ArgStringList CmdArgs;
	const InputInfo &II = Inputs[0];
	
	std::string Exec =
	  Args.MakeArgString(getToolChain().
	    GetProgramPath("openssl"));
	
	// opeenssl base64 arguments
	CmdArgs.push_back("base64");
	CmdArgs.push_back("-in");
	CmdArgs.push_back(II.getFilename());
	CmdArgs.push_back("-out");
	CmdArgs.push_back(Output.getFilename());
	
	C.addCommand(
	  std::make_unique<Command>(
	  		 JA, *this, ResponseFileSupport::None(),
	         Args.MakeArgString(Exec), CmdArgs,
             Inputs, Output));
}
\end{lstlisting}

We are using OpenSSL to do the Base64 encoding, and the command we hope to run is as follows:

\begin{tcblisting}{commandshell={}}
$ openssl base64 -in <input file> -out <output file>
\end{tcblisting}

The job of the ConstructJob method is building a program invocation to run the previous command. It is realized by the C.addCommand(…) function call at the very end of ConstructJob. The Command instance that's passed to the addCommand call represents the concrete command to be run during the assembling stage. It contains necessary information such as the path to the program executable (the Exec variable) and its arguments (the CmdArgs variable).

For the Exec variable, the toolchain has provided a handy utility, the GetProgramPath function, to resolve the absolute path of an executable for you.

The way we build arguments for openssl (the CmdArgs variable), on the other hand, is very similar to the thing we did in the Adding custom driver flags section: translating driver flags (the Args argument) and the input/output file information (the Output and Inputs argument) into a new set of command-line arguments and storing them in CmdArgs.

\item Finally, we connect this Assembler class with ZiplineToolChain by implementing the ZiplineToolChain::buildAssembler method:

\begin{lstlisting}[style=styleCXX]
Tool *ZiplineToolChain::buildAssembler() const {
	return new tools::zipline::Assembler(*this);
}
\end{lstlisting}

\end{enumerate}

These are all the steps we need to follow to create a Tool instance that represents the command to run during the linking stage of our Zipline toolchain.

\subsubsubsection{8.4.4\hspace{0.2cm}Creating a custom linking stage}

Now that we've finished the assembler stage, it's time to move on to the next stage – the linking stage. We are going to use the same approach we used in the previous section; that is, we will create a custom Tool class representing the linker. Here are the steps:

\begin{enumerate}
\item Inside Zipline.h, create a Linker class that is derived from Tool:

\begin{lstlisting}[style=styleCXX]
namespace zipline {
struct LLVM_LIBRARY_VISIBILITY Assembler : public Tool {
	…
};

struct LLVM_LIBRARY_VISIBILITY Linker : public Tool {
	Linker(const ToolChain &TC)
	  : Tool("zipeline::zipper", "zipper", TC) {}
	  
	bool hasIntegratedCPP() const override { return false;
}

	bool isLinkJob() const override { return true; }
	
	void ConstructJob(Compilation &C, const JobAction &JA,
						const InputInfo &Output,
						const InputInfoList &Inputs,
						const llvm::opt::ArgList &TCArgs,
						const char *LinkingOutput) const
						override;
private:
	void buildZipArgs(const JobAction&, const InputInfo&,
						const InputInfoList&,
						const llvm::opt::ArgList&,
						llvm::opt::ArgStringList&) const;
						
	void buildTarArgs(const JobAction&,
						const InputInfo&,
						const InputInfoList&,
						const llvm::opt::ArgList&,
						llvm::opt::ArgStringList&) const;
};
} // end namespace zipline
\end{lstlisting}

In this Linker class, we also need to implement the ConstructJob method to tell the driver what to execute during the linking stage. Differently from Assembler, since we need to support both the zip and tar + gzip packaging/compression schemes, we will add two extra methods, buildZipArgs and buildTarArgs, to handle argument building for each.

\item Inside Zipline.cpp, we'll focus on the implementation of Linker::ConstructJob first:

\begin{lstlisting}[style=styleCXX]
void
tools::zipline::Linker::ConstructJob(Compilation &C,
const JobAction &JA,
const InputInfo &Output,
const InputInfoList &Inputs,
const ArgList &Args,
const char *LinkingOutput) const
{
	ArgStringList CmdArgs;
	std::string Compressor = "zip";
	if (Arg *A = Args.getLastArg(options::OPT_fuse_ld_EQ))
	  Compressor = A->getValue();
	std::string Exec = Args.MakeArgString(
	     getToolChain().GetProgramPath(Compressor.c_str()));
	
	if (Compressor == "zip")
  	  buildZipArgs(JA, Output, Inputs, Args, CmdArgs);
	if (Compressor == "tar" || Compressor == "gzip")
	  buildTarArgs(JA, Output, Inputs, Args, CmdArgs);
	else
	  llvm_unreachable("Unsupported compressor name");
	
	C.addCommand(
	  std::make_unique<Command>(
	    JA, *this, ResponseFileSupport::None(),
	    Args.MakeArgString(Exec),
	    CmdArgs, Inputs, Output));
}
\end{lstlisting}

In this custom linking stage, we hope to use either the zip command or the tar command – depending on the -fuse-ld flag specified by users – to package all the (Base64-encoded) files generated by our custom Assembler.

The detailed command format for both zip and tar will be explained shortly. From the preceding snippet, we can see that the thing we are doing here is similar to Assembler::ConstructJob. The Exec variable carries the absolute path to either the zip or tar program; the CmdArgs variable, which is populated by either buildZipArgs or buildTarArgs, which will be explained later, carries the command-line arguments for the tool (zip or tar).

The biggest difference compared to Assembler::ConstructJob is that the command to execute can be designated by the -fuse-ld flag that's supplied by users. Thus, we are using the skill we learned about in the Adding custom driver flags section to read that driver flag and set up the command.

\item If your users decide to package files in a ZIP file (which is the default scheme, or you can specify it explicitly via -fuse-ld=zip), we are going to run the following command:

\begin{tcblisting}{commandshell={}}
$ zip <output zip file> <input file 1> <input file 2>…
\end{tcblisting}

Therefore, we will build our Linker::buildZipArgs method, which constructs an argument list for the preceding command, as follows:

\begin{lstlisting}[style=styleCXX]
void
tools::zipline::Linker::buildZipArgs(const JobAction &JA,
										const InputInfo &Output,
										const InputInfoList &Inputs,
										const ArgList &Args,
										ArgStringList &CmdArgs) const {
	// output file
	CmdArgs.push_back(Output.getFilename());
	// input files
	AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,
	JA);
}
\end{lstlisting}

The CmdArgs argument of Linker::buildZipArgs will be where we'll export our results. While we are still using the same way to fetch the output filename (via Output.getFilename()), since a linker might accept multiple inputs at a time, we are leveraging another helper function, AddLinkerInputs, to add all the input filenames to CmdArgs for us.

\item If your users decide to use the tar + gzip packaging scheme (via the -fuseld=tar or -fuse-ld=gzip flags), we are going to run the following command:

\begin{tcblisting}{commandshell={}}
$ tar -czf <output tar.gz file> <input file 1> <input file 2>…
\end{tcblisting}

Therefore, we will build our Linker::buildTarArgs method, which constructs an argument list for the previous command, as follows:

\begin{lstlisting}[style=styleCXX]
void
tools::zipline::Linker::buildTarArgs(const JobAction &JA,
										const InputInfo &Output,
										const InputInfoList &Inputs,
										const ArgList &Args,
										ArgStringList &CmdArgs)
										const {
	// arguments and output file
	CmdArgs.push_back("-czf");
	CmdArgs.push_back(Output.getFilename());
	// input files
	AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,
	 JA);
}
\end{lstlisting}

Just like buildZipArgs, we grab the output filename via Output. getFilename() and add all the input filenames, using AddLinkerInput, into CmdArgs.

\item Last but not least, let's connect our Linker to ZiplineToolChain:

\begin{lstlisting}[style=styleCXX]
Tool *ZiplineToolChain::buildLinker() const {
	return new tools::zipline::Linker(*this);
}
\end{lstlisting}

\end{enumerate}

That's all of the steps for implementing a custom linking phase for our Zipline toolchain.

Now that we have created the necessary components for the Zipline toolchain, we can execute our custom features – encode the source files and package them into an archive – when users select this toolchain. In the next section, we are going to learn how to verify these functionalities.

\subsubsubsection{8.4.5\hspace{0.2cm}Verifying the custom toolchain}

To test the functionalities we implemented in this chapter, we can run the example commands depicted in the project overview or we can leverage the -\#\#\# driver flag again to dump all the expected compiler, assembler, and linker command details.

So far, we've learned that the -\#\#\# flag will show all the frontend flags that have been translated by the driver. But actually, it will also show the assembler and linker commands that have been scheduled to run. For instance, let's invoke the following command:

\begin{tcblisting}{commandshell={}}
$ clang -### -zipline -c test.c
\end{tcblisting}

Since the -c flag always tries to run the assembler over the assembly file generated by Clang, our custom assembler (that is, the Base64 encoder) within Zipline will be triggered. Therefore, you will see an output similar to the following:

\begin{tcblisting}{commandshell={}}
$ clang -### -zipline -c test.c
"/path/to/clang" "-cc1" …
"/usr/bin/openssl" "base64" "-in" "/tmp/test_ae4f5b.s" "-out"
"test.o"
$
\end{tcblisting}

The line starting with /path/to/clang -cc1 contains the frontend flags we learned about earlier. The line that follows is the assembler invocation command. This, in our case, runs openssl to perform Base64 encoding.

Note that the weird /tmp/test\_ae4f5b.s filename is the temporary file that's created by the driver to accommodate the assembly code that's generated by the compiler.

Using the same trick, we can verify our custom linker stage, as follows:

\begin{tcblisting}{commandshell={}}
$ clang -### -zipline test.c -o test.zip
"/path/to/clang" "-cc1" …
"/usr/bin/openssl" "base64" "-in" "/tmp/test_ae4f5b.s" "-out"
"/tmp/test_ae4f5b.o"
"/usr/bin/zip" "test.zip" "/tmp/test_ae4f5b.o"
$
\end{tcblisting}

Since the -o flag was used in the previous command, Clang will build a complete executable from test.c involving the assembler and the linker. Therefore, our custom linking stage is up here due to the zip command taking the result (the /tmp/test\_ae4f5b.o file) from the previous assembling stage. Feel free to add the -fuse-ld=tar flag to see the zip command replace the tar command with a completely different argument list.

In this section, we showed you how to create a toolchain for Clang's driver. This is a crucial skill for supporting Clang on custom or new platforms. We also learned that the toolchain framework in Clang is flexible and can handle a variety of tasks that are required by the target platform.
































