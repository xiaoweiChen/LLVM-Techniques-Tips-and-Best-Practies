When it comes to program analysis, AST is usually the recommended medium to use, thanks to its rich amount of semantic information and high-level structures. In this chapter, we learned about the powerful in-memory AST representation that's used in Clang, including its C++ classes and APIs. This gives you a clear picture of the source code you are analyzing.

Furthermore, we learned and practiced a concise way to do pattern matching on AST – a crucial procedure for program analysis – via Clang's ASTMatcher. Familiarizing yourself with this technique can greatly improve your efficiency when it comes to filtering out interesting areas from the input source code. Last but not least, we learned how to write an AST plugin that makes it easier for you to integrate custom logic into the default Clang compilation pipeline.

In the next chapter, we will look at the drivers and toolchains in Clang. We will show you how they work and how to customize them.